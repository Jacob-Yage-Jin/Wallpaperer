# Generated from SAB.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3&")
        buf.write("\u00b2\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\3\2\3\2\3\2\7\2*\n\2\f\2\16\2-\13\2\3\2\3\2\3\3\3\3\3")
        buf.write("\3\3\3\3\3\5\3\66\n\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write("\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3")
        buf.write("\5\3\5\7\5O\n\5\f\5\16\5R\13\5\3\6\3\6\3\6\3\6\3\6\3\6")
        buf.write("\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\b\3")
        buf.write("\b\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\3\t\3\n\3\n\3\13\3\13\3\13\3\13\3\13\3\13\3\13")
        buf.write("\3\13\3\13\3\f\3\f\3\f\3\f\3\f\6\f\u0088\n\f\r\f\16\f")
        buf.write("\u0089\3\r\3\r\3\r\6\r\u008f\n\r\r\r\16\r\u0090\3\r\3")
        buf.write("\r\3\r\3\r\3\16\3\16\3\16\3\16\3\17\3\17\3\20\3\20\3\20")
        buf.write("\3\20\3\20\5\20\u00a2\n\20\3\21\3\21\3\21\3\21\3\22\3")
        buf.write("\22\3\22\3\23\3\23\7\23\u00ad\n\23\f\23\16\23\u00b0\13")
        buf.write("\23\3\23\2\2\24\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36")
        buf.write(" \"$\2\b\3\2\"#\3\2$%\3\2 !\3\2\34\36\3\2\n\r\4\2\17\20")
        buf.write("\22\23\2\u00aa\2&\3\2\2\2\4\65\3\2\2\2\69\3\2\2\2\b?\3")
        buf.write("\2\2\2\nS\3\2\2\2\f]\3\2\2\2\16e\3\2\2\2\20k\3\2\2\2\22")
        buf.write("w\3\2\2\2\24y\3\2\2\2\26\u0087\3\2\2\2\30\u008b\3\2\2")
        buf.write("\2\32\u0096\3\2\2\2\34\u009a\3\2\2\2\36\u009c\3\2\2\2")
        buf.write(" \u00a3\3\2\2\2\"\u00a7\3\2\2\2$\u00aa\3\2\2\2&+\5\4\3")
        buf.write("\2\'(\7\24\2\2(*\5\4\3\2)\'\3\2\2\2*-\3\2\2\2+)\3\2\2")
        buf.write("\2+,\3\2\2\2,.\3\2\2\2-+\3\2\2\2./\7&\2\2/\3\3\2\2\2\60")
        buf.write("\66\5\24\13\2\61\66\5\b\5\2\62\66\5\f\7\2\63\66\5\n\6")
        buf.write("\2\64\66\5\6\4\2\65\60\3\2\2\2\65\61\3\2\2\2\65\62\3\2")
        buf.write("\2\2\65\63\3\2\2\2\65\64\3\2\2\2\66\67\3\2\2\2\678\7\3")
        buf.write("\2\28\5\3\2\2\29:\7\25\2\2:;\7\4\2\2;<\5$\23\2<=\7\4\2")
        buf.write("\2=>\5\36\20\2>\7\3\2\2\2?@\7\30\2\2@A\7\4\2\2AB\5$\23")
        buf.write("\2BC\7\5\2\2CD\7\24\2\2DE\7\22\2\2EF\7\4\2\2FG\5\36\20")
        buf.write("\2GP\5 \21\2HI\7\24\2\2IJ\7\22\2\2JK\7\4\2\2KL\5\36\20")
        buf.write("\2LM\5 \21\2MO\3\2\2\2NH\3\2\2\2OR\3\2\2\2PN\3\2\2\2P")
        buf.write("Q\3\2\2\2Q\t\3\2\2\2RP\3\2\2\2ST\7\27\2\2TU\7\6\2\2UV")
        buf.write("\5$\23\2VW\7\5\2\2WX\7\24\2\2XY\5\36\20\2YZ\5 \21\2Z[")
        buf.write("\7\24\2\2[\\\5\20\t\2\\\13\3\2\2\2]^\7\27\2\2^_\7\7\2")
        buf.write("\2_`\5$\23\2`a\7\5\2\2ab\7\24\2\2bc\5\16\b\2cd\5\20\t")
        buf.write("\2d\r\3\2\2\2ef\7\31\2\2fg\7\4\2\2gh\5\36\20\2hi\5\"\22")
        buf.write("\2ij\7\24\2\2j\17\3\2\2\2kl\t\2\2\2lm\7\4\2\2mn\7\21\2")
        buf.write("\2no\7\24\2\2op\t\3\2\2pq\7\4\2\2qr\7\21\2\2rs\7\24\2")
        buf.write("\2st\7\32\2\2tu\7\4\2\2uv\5\22\n\2v\21\3\2\2\2wx\t\2\2")
        buf.write("\2x\23\3\2\2\2yz\7\26\2\2z{\7\4\2\2{|\5$\23\2|}\7\5\2")
        buf.write("\2}~\7\24\2\2~\177\5\26\f\2\177\u0080\5\30\r\2\u0080\u0081")
        buf.write("\5\32\16\2\u0081\25\3\2\2\2\u0082\u0083\7\22\2\2\u0083")
        buf.write("\u0084\7\4\2\2\u0084\u0085\5$\23\2\u0085\u0086\7\24\2")
        buf.write("\2\u0086\u0088\3\2\2\2\u0087\u0082\3\2\2\2\u0088\u0089")
        buf.write("\3\2\2\2\u0089\u0087\3\2\2\2\u0089\u008a\3\2\2\2\u008a")
        buf.write("\27\3\2\2\2\u008b\u008c\7\33\2\2\u008c\u008e\7\4\2\2\u008d")
        buf.write("\u008f\7\22\2\2\u008e\u008d\3\2\2\2\u008f\u0090\3\2\2")
        buf.write("\2\u0090\u008e\3\2\2\2\u0090\u0091\3\2\2\2\u0091\u0092")
        buf.write("\3\2\2\2\u0092\u0093\7\4\2\2\u0093\u0094\5\34\17\2\u0094")
        buf.write("\u0095\7\24\2\2\u0095\31\3\2\2\2\u0096\u0097\7\37\2\2")
        buf.write("\u0097\u0098\7\4\2\2\u0098\u0099\t\4\2\2\u0099\33\3\2")
        buf.write("\2\2\u009a\u009b\t\5\2\2\u009b\35\3\2\2\2\u009c\u009d")
        buf.write("\7\b\2\2\u009d\u00a1\5$\23\2\u009e\u00a2\5\36\20\2\u009f")
        buf.write("\u00a2\7\b\2\2\u00a0\u00a2\3\2\2\2\u00a1\u009e\3\2\2\2")
        buf.write("\u00a1\u009f\3\2\2\2\u00a1\u00a0\3\2\2\2\u00a2\37\3\2")
        buf.write("\2\2\u00a3\u00a4\5$\23\2\u00a4\u00a5\7\t\2\2\u00a5\u00a6")
        buf.write("\t\6\2\2\u00a6!\3\2\2\2\u00a7\u00a8\5$\23\2\u00a8\u00a9")
        buf.write("\7\16\2\2\u00a9#\3\2\2\2\u00aa\u00ae\7\23\2\2\u00ab\u00ad")
        buf.write("\t\7\2\2\u00ac\u00ab\3\2\2\2\u00ad\u00b0\3\2\2\2\u00ae")
        buf.write("\u00ac\3\2\2\2\u00ae\u00af\3\2\2\2\u00af%\3\2\2\2\u00b0")
        buf.write("\u00ae\3\2\2\2\t+\65P\u0089\u0090\u00a1\u00ae")
        return buf.getvalue()


class SABParser ( Parser ):

    grammarFileName = "SAB.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "' '", "':'", "' IMAGE '", "' TEXT '", 
                     "'/'", "'.'", "'png'", "'jpg'", "'jpeg'", "'bmp'", 
                     "'.sh'", "'-'", "'_'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'SOURCE'", "'SLIDESHOW'", "'OVERLAY'", 
                     "'GROUP'", "'COMMAND'", "'JUSTIFY'", "'TIME'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'ORDER'", "'SHUFFLE'", "'ALPHABETICAL'", 
                     "'RIGHT'", "'LEFT'", "'TOP'", "'BOTTOM'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "PERCENT", 
                      "DIGIT", "LETTER", "NEWLINE", "SOURCE", "SLIDESHOW", 
                      "OVERLAY", "GROUP", "COMMAND", "JUSTIFY", "TIME", 
                      "SECOND", "MINUTE", "HOUR", "ORDER", "SHUFFLE", "ALPHABETICAL", 
                      "RIGHT", "LEFT", "TOP", "BOTTOM", "END" ]

    RULE_s = 0
    RULE_head = 1
    RULE_source = 2
    RULE_group = 3
    RULE_overlay_image = 4
    RULE_overlay_text = 5
    RULE_command = 6
    RULE_position = 7
    RULE_justified_pos = 8
    RULE_slideshow = 9
    RULE_slidesource = 10
    RULE_slidetime = 11
    RULE_slideorder = 12
    RULE_timetype = 13
    RULE_path = 14
    RULE_image = 15
    RULE_script = 16
    RULE_variable = 17

    ruleNames =  [ "s", "head", "source", "group", "overlay_image", "overlay_text", 
                   "command", "position", "justified_pos", "slideshow", 
                   "slidesource", "slidetime", "slideorder", "timetype", 
                   "path", "image", "script", "variable" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    PERCENT=15
    DIGIT=16
    LETTER=17
    NEWLINE=18
    SOURCE=19
    SLIDESHOW=20
    OVERLAY=21
    GROUP=22
    COMMAND=23
    JUSTIFY=24
    TIME=25
    SECOND=26
    MINUTE=27
    HOUR=28
    ORDER=29
    SHUFFLE=30
    ALPHABETICAL=31
    RIGHT=32
    LEFT=33
    TOP=34
    BOTTOM=35
    END=36

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class SContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def head(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SABParser.HeadContext)
            else:
                return self.getTypedRuleContext(SABParser.HeadContext,i)


        def END(self):
            return self.getToken(SABParser.END, 0)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(SABParser.NEWLINE)
            else:
                return self.getToken(SABParser.NEWLINE, i)

        def getRuleIndex(self):
            return SABParser.RULE_s

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterS" ):
                listener.enterS(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitS" ):
                listener.exitS(self)




    def s(self):

        localctx = SABParser.SContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_s)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 36
            self.head()
            self.state = 41
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SABParser.NEWLINE:
                self.state = 37
                self.match(SABParser.NEWLINE)
                self.state = 38
                self.head()
                self.state = 43
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 44
            self.match(SABParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HeadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def slideshow(self):
            return self.getTypedRuleContext(SABParser.SlideshowContext,0)


        def group(self):
            return self.getTypedRuleContext(SABParser.GroupContext,0)


        def overlay_text(self):
            return self.getTypedRuleContext(SABParser.Overlay_textContext,0)


        def overlay_image(self):
            return self.getTypedRuleContext(SABParser.Overlay_imageContext,0)


        def source(self):
            return self.getTypedRuleContext(SABParser.SourceContext,0)


        def getRuleIndex(self):
            return SABParser.RULE_head

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead" ):
                listener.enterHead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead" ):
                listener.exitHead(self)




    def head(self):

        localctx = SABParser.HeadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_head)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 46
                self.slideshow()
                pass

            elif la_ == 2:
                self.state = 47
                self.group()
                pass

            elif la_ == 3:
                self.state = 48
                self.overlay_text()
                pass

            elif la_ == 4:
                self.state = 49
                self.overlay_image()
                pass

            elif la_ == 5:
                self.state = 50
                self.source()
                pass


            self.state = 53
            self.match(SABParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SourceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SOURCE(self):
            return self.getToken(SABParser.SOURCE, 0)

        def variable(self):
            return self.getTypedRuleContext(SABParser.VariableContext,0)


        def path(self):
            return self.getTypedRuleContext(SABParser.PathContext,0)


        def getRuleIndex(self):
            return SABParser.RULE_source

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSource" ):
                listener.enterSource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSource" ):
                listener.exitSource(self)




    def source(self):

        localctx = SABParser.SourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_source)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 55
            self.match(SABParser.SOURCE)
            self.state = 56
            self.match(SABParser.T__1)
            self.state = 57
            self.variable()
            self.state = 58
            self.match(SABParser.T__1)
            self.state = 59
            self.path()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GroupContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GROUP(self):
            return self.getToken(SABParser.GROUP, 0)

        def variable(self):
            return self.getTypedRuleContext(SABParser.VariableContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(SABParser.NEWLINE)
            else:
                return self.getToken(SABParser.NEWLINE, i)

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(SABParser.DIGIT)
            else:
                return self.getToken(SABParser.DIGIT, i)

        def path(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SABParser.PathContext)
            else:
                return self.getTypedRuleContext(SABParser.PathContext,i)


        def image(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SABParser.ImageContext)
            else:
                return self.getTypedRuleContext(SABParser.ImageContext,i)


        def getRuleIndex(self):
            return SABParser.RULE_group

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup" ):
                listener.enterGroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup" ):
                listener.exitGroup(self)




    def group(self):

        localctx = SABParser.GroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_group)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            self.match(SABParser.GROUP)
            self.state = 62
            self.match(SABParser.T__1)
            self.state = 63
            self.variable()
            self.state = 64
            self.match(SABParser.T__2)
            self.state = 65
            self.match(SABParser.NEWLINE)
            self.state = 66
            self.match(SABParser.DIGIT)
            self.state = 67
            self.match(SABParser.T__1)
            self.state = 68
            self.path()
            self.state = 69
            self.image()
            self.state = 78
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SABParser.NEWLINE:
                self.state = 70
                self.match(SABParser.NEWLINE)
                self.state = 71
                self.match(SABParser.DIGIT)
                self.state = 72
                self.match(SABParser.T__1)
                self.state = 73
                self.path()
                self.state = 74
                self.image()
                self.state = 80
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Overlay_imageContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVERLAY(self):
            return self.getToken(SABParser.OVERLAY, 0)

        def variable(self):
            return self.getTypedRuleContext(SABParser.VariableContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(SABParser.NEWLINE)
            else:
                return self.getToken(SABParser.NEWLINE, i)

        def path(self):
            return self.getTypedRuleContext(SABParser.PathContext,0)


        def image(self):
            return self.getTypedRuleContext(SABParser.ImageContext,0)


        def position(self):
            return self.getTypedRuleContext(SABParser.PositionContext,0)


        def getRuleIndex(self):
            return SABParser.RULE_overlay_image

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOverlay_image" ):
                listener.enterOverlay_image(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOverlay_image" ):
                listener.exitOverlay_image(self)




    def overlay_image(self):

        localctx = SABParser.Overlay_imageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_overlay_image)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self.match(SABParser.OVERLAY)
            self.state = 82
            self.match(SABParser.T__3)
            self.state = 83
            self.variable()
            self.state = 84
            self.match(SABParser.T__2)
            self.state = 85
            self.match(SABParser.NEWLINE)
            self.state = 86
            self.path()
            self.state = 87
            self.image()
            self.state = 88
            self.match(SABParser.NEWLINE)
            self.state = 89
            self.position()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Overlay_textContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVERLAY(self):
            return self.getToken(SABParser.OVERLAY, 0)

        def variable(self):
            return self.getTypedRuleContext(SABParser.VariableContext,0)


        def NEWLINE(self):
            return self.getToken(SABParser.NEWLINE, 0)

        def command(self):
            return self.getTypedRuleContext(SABParser.CommandContext,0)


        def position(self):
            return self.getTypedRuleContext(SABParser.PositionContext,0)


        def getRuleIndex(self):
            return SABParser.RULE_overlay_text

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOverlay_text" ):
                listener.enterOverlay_text(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOverlay_text" ):
                listener.exitOverlay_text(self)




    def overlay_text(self):

        localctx = SABParser.Overlay_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_overlay_text)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self.match(SABParser.OVERLAY)
            self.state = 92
            self.match(SABParser.T__4)
            self.state = 93
            self.variable()
            self.state = 94
            self.match(SABParser.T__2)
            self.state = 95
            self.match(SABParser.NEWLINE)
            self.state = 96
            self.command()
            self.state = 97
            self.position()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CommandContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMAND(self):
            return self.getToken(SABParser.COMMAND, 0)

        def path(self):
            return self.getTypedRuleContext(SABParser.PathContext,0)


        def script(self):
            return self.getTypedRuleContext(SABParser.ScriptContext,0)


        def NEWLINE(self):
            return self.getToken(SABParser.NEWLINE, 0)

        def getRuleIndex(self):
            return SABParser.RULE_command

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommand" ):
                listener.enterCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommand" ):
                listener.exitCommand(self)




    def command(self):

        localctx = SABParser.CommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_command)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.match(SABParser.COMMAND)
            self.state = 100
            self.match(SABParser.T__1)
            self.state = 101
            self.path()
            self.state = 102
            self.script()
            self.state = 103
            self.match(SABParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PositionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERCENT(self, i:int=None):
            if i is None:
                return self.getTokens(SABParser.PERCENT)
            else:
                return self.getToken(SABParser.PERCENT, i)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(SABParser.NEWLINE)
            else:
                return self.getToken(SABParser.NEWLINE, i)

        def JUSTIFY(self):
            return self.getToken(SABParser.JUSTIFY, 0)

        def justified_pos(self):
            return self.getTypedRuleContext(SABParser.Justified_posContext,0)


        def RIGHT(self):
            return self.getToken(SABParser.RIGHT, 0)

        def LEFT(self):
            return self.getToken(SABParser.LEFT, 0)

        def TOP(self):
            return self.getToken(SABParser.TOP, 0)

        def BOTTOM(self):
            return self.getToken(SABParser.BOTTOM, 0)

        def getRuleIndex(self):
            return SABParser.RULE_position

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosition" ):
                listener.enterPosition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosition" ):
                listener.exitPosition(self)




    def position(self):

        localctx = SABParser.PositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_position)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            _la = self._input.LA(1)
            if not(_la==SABParser.RIGHT or _la==SABParser.LEFT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 106
            self.match(SABParser.T__1)
            self.state = 107
            self.match(SABParser.PERCENT)
            self.state = 108
            self.match(SABParser.NEWLINE)
            self.state = 109
            _la = self._input.LA(1)
            if not(_la==SABParser.TOP or _la==SABParser.BOTTOM):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 110
            self.match(SABParser.T__1)
            self.state = 111
            self.match(SABParser.PERCENT)
            self.state = 112
            self.match(SABParser.NEWLINE)
            self.state = 113
            self.match(SABParser.JUSTIFY)
            self.state = 114
            self.match(SABParser.T__1)
            self.state = 115
            self.justified_pos()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Justified_posContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGHT(self):
            return self.getToken(SABParser.RIGHT, 0)

        def LEFT(self):
            return self.getToken(SABParser.LEFT, 0)

        def getRuleIndex(self):
            return SABParser.RULE_justified_pos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJustified_pos" ):
                listener.enterJustified_pos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJustified_pos" ):
                listener.exitJustified_pos(self)




    def justified_pos(self):

        localctx = SABParser.Justified_posContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_justified_pos)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            _la = self._input.LA(1)
            if not(_la==SABParser.RIGHT or _la==SABParser.LEFT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SlideshowContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLIDESHOW(self):
            return self.getToken(SABParser.SLIDESHOW, 0)

        def variable(self):
            return self.getTypedRuleContext(SABParser.VariableContext,0)


        def NEWLINE(self):
            return self.getToken(SABParser.NEWLINE, 0)

        def slidesource(self):
            return self.getTypedRuleContext(SABParser.SlidesourceContext,0)


        def slidetime(self):
            return self.getTypedRuleContext(SABParser.SlidetimeContext,0)


        def slideorder(self):
            return self.getTypedRuleContext(SABParser.SlideorderContext,0)


        def getRuleIndex(self):
            return SABParser.RULE_slideshow

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSlideshow" ):
                listener.enterSlideshow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSlideshow" ):
                listener.exitSlideshow(self)




    def slideshow(self):

        localctx = SABParser.SlideshowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_slideshow)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.match(SABParser.SLIDESHOW)
            self.state = 120
            self.match(SABParser.T__1)
            self.state = 121
            self.variable()
            self.state = 122
            self.match(SABParser.T__2)
            self.state = 123
            self.match(SABParser.NEWLINE)
            self.state = 124
            self.slidesource()
            self.state = 125
            self.slidetime()
            self.state = 126
            self.slideorder()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SlidesourceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(SABParser.DIGIT)
            else:
                return self.getToken(SABParser.DIGIT, i)

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SABParser.VariableContext)
            else:
                return self.getTypedRuleContext(SABParser.VariableContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(SABParser.NEWLINE)
            else:
                return self.getToken(SABParser.NEWLINE, i)

        def getRuleIndex(self):
            return SABParser.RULE_slidesource

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSlidesource" ):
                listener.enterSlidesource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSlidesource" ):
                listener.exitSlidesource(self)




    def slidesource(self):

        localctx = SABParser.SlidesourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_slidesource)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 128
                self.match(SABParser.DIGIT)
                self.state = 129
                self.match(SABParser.T__1)
                self.state = 130
                self.variable()
                self.state = 131
                self.match(SABParser.NEWLINE)
                self.state = 135 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==SABParser.DIGIT):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SlidetimeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIME(self):
            return self.getToken(SABParser.TIME, 0)

        def timetype(self):
            return self.getTypedRuleContext(SABParser.TimetypeContext,0)


        def NEWLINE(self):
            return self.getToken(SABParser.NEWLINE, 0)

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(SABParser.DIGIT)
            else:
                return self.getToken(SABParser.DIGIT, i)

        def getRuleIndex(self):
            return SABParser.RULE_slidetime

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSlidetime" ):
                listener.enterSlidetime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSlidetime" ):
                listener.exitSlidetime(self)




    def slidetime(self):

        localctx = SABParser.SlidetimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_slidetime)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.match(SABParser.TIME)
            self.state = 138
            self.match(SABParser.T__1)
            self.state = 140 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 139
                self.match(SABParser.DIGIT)
                self.state = 142 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==SABParser.DIGIT):
                    break

            self.state = 144
            self.match(SABParser.T__1)
            self.state = 145
            self.timetype()
            self.state = 146
            self.match(SABParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SlideorderContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER(self):
            return self.getToken(SABParser.ORDER, 0)

        def SHUFFLE(self):
            return self.getToken(SABParser.SHUFFLE, 0)

        def ALPHABETICAL(self):
            return self.getToken(SABParser.ALPHABETICAL, 0)

        def getRuleIndex(self):
            return SABParser.RULE_slideorder

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSlideorder" ):
                listener.enterSlideorder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSlideorder" ):
                listener.exitSlideorder(self)




    def slideorder(self):

        localctx = SABParser.SlideorderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_slideorder)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148
            self.match(SABParser.ORDER)
            self.state = 149
            self.match(SABParser.T__1)
            self.state = 150
            _la = self._input.LA(1)
            if not(_la==SABParser.SHUFFLE or _la==SABParser.ALPHABETICAL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TimetypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SECOND(self):
            return self.getToken(SABParser.SECOND, 0)

        def MINUTE(self):
            return self.getToken(SABParser.MINUTE, 0)

        def HOUR(self):
            return self.getToken(SABParser.HOUR, 0)

        def getRuleIndex(self):
            return SABParser.RULE_timetype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimetype" ):
                listener.enterTimetype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimetype" ):
                listener.exitTimetype(self)




    def timetype(self):

        localctx = SABParser.TimetypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_timetype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SABParser.SECOND) | (1 << SABParser.MINUTE) | (1 << SABParser.HOUR))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PathContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(SABParser.VariableContext,0)


        def path(self):
            return self.getTypedRuleContext(SABParser.PathContext,0)


        def getRuleIndex(self):
            return SABParser.RULE_path

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPath" ):
                listener.enterPath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPath" ):
                listener.exitPath(self)




    def path(self):

        localctx = SABParser.PathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_path)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(SABParser.T__5)
            self.state = 155
            self.variable()
            self.state = 159
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 156
                self.path()
                pass

            elif la_ == 2:
                self.state = 157
                self.match(SABParser.T__5)
                pass

            elif la_ == 3:
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ImageContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(SABParser.VariableContext,0)


        def getRuleIndex(self):
            return SABParser.RULE_image

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImage" ):
                listener.enterImage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImage" ):
                listener.exitImage(self)




    def image(self):

        localctx = SABParser.ImageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_image)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self.variable()
            self.state = 162
            self.match(SABParser.T__6)
            self.state = 163
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SABParser.T__7) | (1 << SABParser.T__8) | (1 << SABParser.T__9) | (1 << SABParser.T__10))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ScriptContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(SABParser.VariableContext,0)


        def getRuleIndex(self):
            return SABParser.RULE_script

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScript" ):
                listener.enterScript(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScript" ):
                listener.exitScript(self)




    def script(self):

        localctx = SABParser.ScriptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_script)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.variable()
            self.state = 166
            self.match(SABParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LETTER(self, i:int=None):
            if i is None:
                return self.getTokens(SABParser.LETTER)
            else:
                return self.getToken(SABParser.LETTER, i)

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(SABParser.DIGIT)
            else:
                return self.getToken(SABParser.DIGIT, i)

        def getRuleIndex(self):
            return SABParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)




    def variable(self):

        localctx = SABParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_variable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.match(SABParser.LETTER)
            self.state = 172
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 169
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SABParser.T__12) | (1 << SABParser.T__13) | (1 << SABParser.DIGIT) | (1 << SABParser.LETTER))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 174
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





